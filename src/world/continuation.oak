;;; Copyright (C) 1988,7, Barak A. Pearlmutter & Kevin J. Lang.

;;; First class continuations.  The interface is call/cc, like it should be.


(define-instance continuation type
  '(val-segs val-offset cxt-segs cxt-offset saved-windings saved-wind-count)
  (list object))

(%your-top-wired continuation)

;;;(add-method (length (type instance-length) self)
;;;  instance-length)
;;;(define-constant %continuation-size (length continuation))

(define-constant %continuation-size 7)

(set! %%cleanup-needed #f)

(define (call/cc f)
  (bind ()
    (block0
     (%call/cc f)
     (when %%cleanup-needed
       (set! %%cleanup-needed #f)
       (rewind %%join-count %%new-windings %%new-wind-count)))))

(define call-with-current-continuation call/cc)

(define-constant %continue
  (add-method ((make-open-coded-operation
		(lambda (ignore)
		  '((continue)))
		2 1)
	       (continuation) self v)
    (%continue self v)))

(define-constant %fill-continuation
  (add-method ((make-open-coded-operation
		(lambda (ignore)
		  '((fill-continuation)))
		1 1)
	       (continuation) self)
    (%fill-continuation self)))


;;; WARNING!  CAUTION!  Do not modify this definition of %CALL/CC
;;; unless you really know what you are doing.  It is carefully tuned
;;; to leave exactly the right amount of stuff on the stack when
;;; %FILL-CONTINUATION is called.
;;;
;;; If the compiler is changed, it would be wise to make sure that
;;; this still works.

(define (%call/cc f)
  (let ((tag (%fill-continuation (%allocate continuation %continuation-size))))
    (set! ((%slot 5) tag) %windings)
    (set! ((%slot 6) tag) %wind-count)
    (f (lambda (v)
	 (let ((join-count (find-join-point %windings %wind-count
					    ((%slot 5) tag) ((%slot 6) tag))))
	   (unwind %windings %wind-count join-count)
	   ;; We'd like to do this now, but we're in the wrong stack context,
	   ;;  so we'll remember to do it once we get there.
	   ;;(rewind join-count ((%slot 5) tag) ((%slot 6) tag))

	   ;;This is the first time I've been forced to pass parameters by
	   ;; stashing them in globals in Lisp!
	   (set! %%join-count join-count)
	   (set! %%new-windings ((%slot 5) tag))
	   (set! %%new-wind-count ((%slot 6) tag))
	   (set! %%cleanup-needed #t)
	   )
	 (%continue tag v)))))

#|
;;; This is the code generated by the preceding DEFINE:
((LOAD-CODE
  (CODE ()
    ((CHECK-NARGS 1)
     (LOAD-IMM 5)
     (LOAD-GLO-CON CONTINUATION)
     (ALLOCATE)
     ;; F and the continuation object are on the stack here, and the saved
     ;; continuation should have the stack checkpointed without those
     ;; two guys on it.  This is controled in the emulator code for the
     ;; fill-continuation instruction.
     (FILL-CONTINUATION)
     (MAKE-CELL) (LOAD-STK 0 TAG) (MAKE-CLOSED-ENVIRONMENT 1)
     ;; <code to do the slot setting stuff>
     (LOAD-CODE
      (CODE ()
	    ((CHECK-NARGS 1) (LOAD-STK 0 V) (LOAD-ENV 2 TAG) (CONTENTS)
	     (LOAD-GLO-CON %CONTINUE) (STORE-NARGS 2) (BLT-STK 3 1)
	     (FUNCALL-TAIL))))
     (LOAD-GLO-CON %INSTALL-LAMBDA-WITH-ENV) (STORE-NARGS 2) (FUNCALL-CXT)
     (LOAD-STK 2 F) (STORE-NARGS 1) (BLT-STK 2 2) (FUNCALL-TAIL))))
 (LOAD-GLO-CON %INSTALL-LAMBDA) (STORE-NARGS 1) (FUNCALL-CXT)
 (LOAD-GLO %CALL/CC) (SET-CONTENTS) (RETURN))
|#

;;; eof
